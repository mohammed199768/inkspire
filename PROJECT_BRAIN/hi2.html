<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inkspire - The Creative Arc</title>
    <style>
        body { 
            margin: 0; 
            background: radial-gradient(circle at center, #1a1b3a 0%, #050510 100%);
            overflow: hidden; 
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }

        #canvas-container { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; 
        }

        .ui-layer {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 20; pointer-events: none; text-align: center;
        }
        .scroll-hint {
            font-size: 10px; letter-spacing: 3px; text-transform: uppercase; opacity: 0.5;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0%,100%{opacity: 0.3;} 50%{opacity: 0.8;} }

        .progress-bar {
            position: fixed; right: 30px; top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 10px; z-index: 20;
        }
        .dot {
            width: 6px; height: 6px; background: rgba(255,255,255,0.2); border-radius: 50%;
            transition: 0.3s;
        }
        .dot.active { background: #a0a0ff; box-shadow: 0 0 10px #a0a0ff; transform: scale(1.5); }

        section {
            position: absolute; top: 0; left: 0; width: 100%; height: 100vh;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; transform: translateY(50px) scale(0.9); 
            transition: all 1s cubic-bezier(0.23, 1, 0.32, 1);
            pointer-events: none; z-index: 10;
            text-align: center;
        }

        section.active {
            opacity: 1; transform: translateY(0) scale(1); 
        }

        h1 { 
            font-size: clamp(3rem, 5vw, 6rem); font-weight: 800; margin: 0;
            background: linear-gradient(135deg, #fff 0%, #a0a0ff 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 10px 30px rgba(107, 64, 146, 0.3);
        }
        p { 
            font-size: 1.2rem; color: #b0b0d0; letter-spacing: 2px; text-transform: uppercase;
            margin-top: 10px; font-weight: 300;
        }
        .sub-text {
            font-size: 0.9rem; opacity: 0.6; margin-top: 5px; font-style: italic; letter-spacing: 1px;
        }

        #error-box {
            position: fixed; top: 10px; left: 10px; background: red; color: white;
            padding: 10px; display: none; z-index: 9999;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>

    <div id="error-box"></div>
    <div id="canvas-container"></div>

    <div class="ui-layer">
        <div class="scroll-hint">Scroll to Create</div>
    </div>

    <div class="progress-bar" id="dots-container"></div>

    <section id="s0" class="active"><h1>NOISE</h1><p>01. The Chaos</p><div class="sub-text">Inspiration begins in the void</div></section>
    <section id="s1"><h1>SPARK</h1><p>02. The Core</p><div class="sub-text">A single point of focus</div></section>
    <section id="s2"><h1>STROKE</h1><p>03. The Line</p><div class="sub-text">Direction emerges</div></section>
    <section id="s3"><h1>GESTURE</h1><p>04. The Curve</p><div class="sub-text">Adding humanity & flow</div></section>
    <section id="s4"><h1>QUILL</h1><p>05. The Tool</p><div class="sub-text">The identity takes shape</div></section>
    <section id="s5"><h1>GLYPH</h1><p>06. The Letter</p><div class="sub-text">Idea becomes language</div></section>
    <section id="s6"><h1>GRID</h1><p>07. Structure</p><div class="sub-text">Chaos tamed by design</div></section>
    <section id="s7"><h1>RIPPLE</h1><p>08. Impact</p><div class="sub-text">Resonating outwards</div></section>
    <section id="s8"><h1>MARK</h1><p>09. Signature</p><div class="sub-text">What remains</div></section>

<script>
    window.onerror = function(msg, url, line) {
        document.getElementById('error-box').style.display = 'block';
        document.getElementById('error-box').innerHTML = `Error: ${msg}<br>Line: ${line}`;
    };

    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050510, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.z = 120;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const count = 2000; // تخفيض العدد للأداء الأفضل مع الحفاظ على الشكل
    const dummy = new THREE.Object3D();
    const shapes = []; 

    function generateShapes() {
        for (let s = 0; s < 9; s++) {
            const shapeData = [];
            for (let i = 0; i < count; i++) {
                let x, y, z;
                
                const ratio = i / count;
                const theta = ratio * Math.PI * 2;
                
                switch(s) {
                    case 0: // NOISE
                        const spread = 600;
                        x = (Math.random() - 0.5) * spread;
                        y = (Math.random() - 0.5) * spread;
                        z = (Math.random() - 0.5) * spread;
                        break;
                    
                    case 1: // SPARK
                        const rSpark = 5 + Math.random() * 15;
                        const u = Math.random();
                        const v = Math.random();
                        const thetaSpark = 2 * Math.PI * u;
                        const phiSpark = Math.acos(2 * v - 1);
                        x = rSpark * Math.sin(phiSpark) * Math.cos(thetaSpark);
                        y = rSpark * Math.sin(phiSpark) * Math.sin(thetaSpark);
                        z = rSpark * Math.cos(phiSpark);
                        if(i % 20 === 0) { x *= 4; y *= 4; z *= 4; }
                        break;

                    case 2: // STROKE (تعديل: ضربة فرشاة احترافية)
                        // الطول الكلي للخط
                        const strokeLen = 300;
                        x = (ratio - 0.5) * strokeLen;
                        
                        // انحناءة الخط (Swoosh)
                        // يبدأ منحنياً قليلاً وينتهي مستقيماً
                        y = Math.sin(ratio * Math.PI) * 20 - (ratio * 30);
                        
                        // السماكة المتغيرة (Tapering)
                        // رفيع في الأطراف، سميك في الوسط
                        const thickness = Math.sin(ratio * Math.PI) * 12;
                        
                        // توزيع عشوائي داخل السماكة لمحاكاة شعيرات الفرشاة
                        const rAngle = Math.random() * Math.PI * 2;
                        const rDist = Math.random() * thickness;
                        
                        y += Math.sin(rAngle) * rDist;
                        z = Math.cos(rAngle) * rDist;
                        
                        // إضافة بعض "الرذاذ" في نهاية الضربة
                        if (ratio > 0.95 && Math.random() > 0.5) {
                            x += Math.random() * 20;
                            y += (Math.random() - 0.5) * 30;
                        }
                        break;

                    case 3: // CURVE
                        const range = 250;
                        x = (ratio - 0.5) * range;
                        y = Math.sin(x * 0.02) * 50; 
                        z = Math.cos(x * 0.01) * 30;
                        x += (Math.random() - 0.5) * 5;
                        y += (Math.random() - 0.5) * 5;
                        break;

                    case 4: // QUILL (الريشة الواقعية - النسخة المحدثة)
                        const t = i / count; 
                        // تشكيل القصبة
                        const spineX = Math.sin(t * 2) * 5; 
                        const spineY = (t - 0.5) * 220;
                        const spineZ = Math.pow(t, 2) * 40; 

                        if (t < 0.15) { // المقبض
                            const angle = Math.random() * Math.PI * 2;
                            const rHandle = 2;
                            x = spineX + Math.cos(angle) * rHandle;
                            y = spineY;
                            z = spineZ + Math.sin(angle) * rHandle;
                        } else { // الشعيرات
                            const t2 = (t - 0.15) / 0.85;
                            const side = (i % 2 === 0) ? 1 : -1; 
                            const asymmetry = (side === 1) ? 1.0 : 0.6; 
                            const widthProfile = Math.sin(Math.pow(t2, 0.7) * Math.PI); 
                            const maxBarbLen = 70 * widthProfile * asymmetry;
                            const barbPos = Math.pow(Math.random(), 0.8); 
                            const currentLen = barbPos * maxBarbLen;
                            const barbAngle = Math.PI * 0.15; 
                            
                            let localX = side * currentLen; 
                            let localY = Math.abs(currentLen) * Math.tan(barbAngle);
                            let localZ = Math.pow(barbPos, 2) * 15; 

                            if (barbPos > 0.8) localY += (Math.random() - 0.5) * 10;

                            x = spineX + localX;
                            y = spineY + localY;
                            z = spineZ + localZ;
                        }
                        break;

                    case 5: // GLYPH
                        const lineNum = i % 3; 
                        const lineHeight = 40;
                        y = (lineNum - 1) * lineHeight;
                        const wordBlock = Math.floor((i/count) * 10); 
                        if(wordBlock % 2 === 0) x = 1000; 
                        else x = ((i/count) - 0.5) * 300; 
                        
                        const seg = (i / 100);
                        if (Math.sin(seg) > 0) x = (ratio - 0.5) * 250;
                        else { x = (ratio - 0.5) * 250; y += 1000; }
                        z = 0;
                        break;

                    case 6: // GRID
                        const gridSize = 45; // تعديل للحجم الجديد (2000)
                        const row = Math.floor(i / gridSize);
                        const col = i % gridSize;
                        const spacing = 8;
                        x = (col - gridSize/2) * spacing;
                        z = (row - (count/gridSize)/2) * spacing;
                        y = 0;
                        if (Math.random() > 0.95) y = 10; 
                        break;

                    case 7: // RIPPLE (تعديل: مواجهة للكاميرا، والعمق في Z)
                        const maxR = 120;
                        const rRipple = ratio * maxR; 
                        // كثافة عالية للدوائر
                        const thetaRipple = ratio * 150; 
                        
                        // الدائرة ترسم على X و Y (تواجه الكاميرا)
                        x = Math.cos(thetaRipple) * rRipple;
                        y = Math.sin(thetaRipple) * rRipple;
                        
                        // التموج والعمق يحدث في Z
                        // مسافة من المركز
                        const distFromCenter = rRipple;
                        // موجة تتلاشى كلما ابتعدنا
                        z = Math.sin(distFromCenter * 0.2) * 20;
                        
                        // إضافة ميلان بسيط لتبدو كبوابة
                        z += (ratio - 0.5) * 10;
                        break;

                    case 8: // MARK
                        if (i < count * 0.2) {
                            const rDot = 4;
                            const u2 = Math.random();
                            const v2 = Math.random();
                            const t2 = 2 * Math.PI * u2;
                            const p2 = Math.acos(2 * v2 - 1);
                            x = rDot * Math.sin(p2) * Math.cos(t2) + 20; 
                            y = rDot * Math.sin(p2) * Math.sin(t2);
                            z = rDot * Math.cos(p2);
                        } else {
                            x = ((i - count*0.2) / (count*0.8) - 0.5) * 40 - 10;
                            y = -10;
                            z = (Math.random() - 0.5) * 2;
                        }
                        break;
                }
                shapeData.push(x, y, z);
            }
            shapes.push(shapeData);
        }
    }
    generateShapes();

    // Geometry & Material
    // تكبير الحجم قليلاً (0.9) لتعويض نقص العدد
    const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9); 
    const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const mesh = new THREE.InstancedMesh(geometry, material, count);
    
    const color1 = new THREE.Color(0xffffff); 
    const color2 = new THREE.Color(0xa0a0ff); 
    const color3 = new THREE.Color(0x6b4092); 
    
    for (let i = 0; i < count; i++) {
        dummy.position.set(0,0,0);
        dummy.updateMatrix();
        mesh.setMatrixAt(i, dummy.matrix);
        
        let c = Math.random();
        let finalColor;
        if(c < 0.3) finalColor = color1;
        else if(c < 0.7) finalColor = color2;
        else finalColor = color3;
        
        mesh.setColorAt(i, finalColor);
    }
    scene.add(mesh);

    let currentShapeIndex = 0;
    let targetShapeIndex = 0;
    const animParams = { progress: 0 }; 

    function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.0005;
        
        scene.rotation.y = Math.sin(time * 0.2) * 0.1;
        scene.rotation.x = Math.cos(time * 0.3) * 0.05;

        if (targetShapeIndex !== currentShapeIndex || animParams.progress > 0) {
            
            const startShape = shapes[currentShapeIndex];
            const endShape = shapes[targetShapeIndex];

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                const x = THREE.MathUtils.lerp(startShape[i3], endShape[i3], animParams.progress);
                const y = THREE.MathUtils.lerp(startShape[i3+1], endShape[i3+1], animParams.progress);
                const z = THREE.MathUtils.lerp(startShape[i3+2], endShape[i3+2], animParams.progress);

                const noise = Math.sin(time * 2 + i * 0.1) * 0.3;
                
                dummy.position.set(x + noise, y + noise, z);
                
                // توجيه الجزيئات
                if (targetShapeIndex === 6) dummy.rotation.set(0,0,0); 
                else dummy.lookAt(camera.position); 

                const scale = 1 + Math.sin(time * 5 + i) * 0.4;
                dummy.scale.setScalar(scale); 

                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            mesh.instanceMatrix.needsUpdate = true;
        }

        renderer.render(scene, camera);
    }
    animate();

    const totalSections = 9;
    let isAnimating = false;
    
    const dotsContainer = document.getElementById('dots-container');
    const dots = [];
    for(let i=0; i<totalSections; i++) {
        const d = document.createElement('div');
        d.className = i===0 ? 'dot active' : 'dot';
        dotsContainer.appendChild(d);
        dots.push(d);
    }

    function goToSection(index) {
        if(isAnimating || index < 0 || index >= totalSections) return;
        isAnimating = true;

        document.querySelectorAll('section').forEach(s => s.classList.remove('active'));
        document.getElementById('s' + index).classList.add('active');
        
        dots.forEach(d => d.classList.remove('active'));
        dots[index].classList.add('active');

        targetShapeIndex = index;
        animParams.progress = 0;
        
        gsap.to(animParams, {
            progress: 1,
            duration: 1.8,
            ease: "power2.inOut",
            onComplete: () => {
                currentShapeIndex = targetShapeIndex;
                animParams.progress = 0; 
                isAnimating = false;
            }
        });
        
        let camZ = 120;
        if(index === 1) camZ = 60; 
        if(index === 6) camZ = 140; 
        if(index === 8) camZ = 80;  

        gsap.to(camera.position, {
            z: camZ,
            duration: 2,
            ease: "power2.inOut"
        });
    }

    window.addEventListener('wheel', (e) => {
        if(isAnimating) return;
        if(Math.abs(e.deltaY) < 30) return;
        
        if(e.deltaY > 0) goToSection(targetShapeIndex + 1);
        else goToSection(targetShapeIndex - 1);
    });

    window.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowDown' || e.key === 'ArrowRight') goToSection(targetShapeIndex + 1);
        if(e.key === 'ArrowUp' || e.key === 'ArrowLeft') goToSection(targetShapeIndex - 1);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>